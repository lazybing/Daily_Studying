# [一个有效的使用了有限状态机(FSM)的高斯模糊算法](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.177.3190&rep=rep1&type=pdf)

## 前言

二维的高斯模糊算法被用到了很多的图像处理应用中，因为运算量巨大，高斯模糊会非常耗时，尤其是涉及大的核函数时，正确使用高斯模糊的两个属性可以降低运算时间:

1. 大内核可以被分解为小内核的顺序应用。
2. 高斯模糊被分解成行和列的操作。

本篇论文利用以上两点的同时，添加了第 3 点: 

3. 行操作和列操作可以公式化为有限状态机，从而产生更高效的代码，并且对于多步分解，无需写入中间图像。

本论文展示了高斯模糊的有限状态机公式的一般情况，并提供了例子。不同实现间的速度比较同样给出了例子。本文的重点是软件实现，同样也会讨论流水线硬件实现。同时会介绍扩展内容，即三维或多维图像处理的内容。同时，高斯差分滤波器(DOG, Difference-of-Guassian filters)也会提到。

## 1. 介绍

图像处理中使用了各种低通滤波器的操作，低通是指允许低频信号通过、拒绝高频分量。低通通常被命名为平滑、平均、模糊。这种类型的最广泛使用之一就是高斯模糊，它的优点是非常平滑并且圆对称，因此任意方向上的边线都有相似的处理。对于数字图像处理，模糊操作通常定义在较小的邻域、较小的有限范围内的灰度级别。在这种情况下，理想的高斯“钟形曲线”必须用几个整数值来近似。通常使用的数值是基于Pascal三角形的，随着点数的增加，这些数值越来越接近真实的高斯曲线。

这些系数具有非常有用的性质，即N=k的集合可以通过将N=i的集合与N=j的集合进行卷积得到，其中k=i+j。例如，N=7的集合可以通过将[1 3 3 1]与[1 4 6 4 1]卷积来获得。这绝对是至关重要的含义是，重复应用小邻域高斯模糊可以实现大邻域高斯模糊。这些结果完全相等，除了由于连续运算而累积的舍入误差。对于一维高斯算子、二维算子和所有高维算子都是如此。

二维高斯模糊运算在许多图像处理应用中都有应用。这些操作的执行时间可能相当长，特别是在涉及大内核的情况下。正确使用高斯模糊的两个特性有助于减少这些较长的执行时间:
1. 如上文所述，大内核可以分解为小内核的顺序应用。
2. 高斯模糊可分为独立的行和列操作。
3. 行和列操作可以表示为有限状态机（fsm），以产生高效的代码。此外，对于多步顺序分解，无需将结果写入中间图像，然后获取这些结果以供下一步操作。

## 2. 基础的 2x2 操作

图 1 显示了最简单的二维操作符，2x2 模糊，它有两行[1 1]和[1 1],使用 SKIPSM(使用有限状态机的分离内核图像处理) 范例实现。

该实现需要一个用于行机器 SR0 的状态的存储器位置或寄存器和列状态缓冲器 SC0[i], i=1,2,...NPixels,其中 NPixels 是图像行中的像素值。列状态缓冲区在整个操作开始时设置为零，行状态缓冲区在每行开始时设置为零。

对于本例和接下来的所有其他示例，每个图像像素只提取一次。对于每个像素，下面显示的主循环代码执行一次。没有其他步骤。如果需要，可以将输出写回输入图像，因为计算输出所需的所有信息都包含在状态缓冲区中。

这个 2x2 SKIPSM 实现使用五个步骤(或六个步骤，如果其中一个步骤 4 被看作两个步骤的话)，而纯暴力实现将使用九个步骤（四个双索引像素提取、三个加法、一个缩放步骤和对输出图像的双索引`写入`）。在这种情况下，SKIPSM 的结果并不是特别令人印象深刻。SKIPSM 的真正优势随着操作符的大小增加而增加。当然，没有人会使用暴力手段这样麻烦的手段。(注意：在步骤4中加上值2可四舍五入到最接近的整数。）

## 3. Larger Blurs:3x3 和 5x5

此实现需要两个临时变量，一个内存位置或行机器状态寄存器（SR0），对于每行中有NPixels的图像，一个列状态缓冲区SC0[i]，i=1，2，…NPixels。3x3实现需要两个临时变量、两个用于行机器状态的内存位置或寄存器SR0和SR1，以及两个列状态缓冲区SC0[i]和SC1[i]。列状态缓冲区在整个操作开始时设置为零，行状态缓冲区在每行开始时设置为零。主循环代码如下所示。输出被写入地址[j-1][i-1]，因为这是当前3x3邻域的中心。

因此，3x3 SKIPSM的实现需要9个步骤。在这种情况下，暴力法需要24个步骤（9个双索引像素提取、5个乘法、8个加法、一个缩放步骤和对输出图像的双索引“写入”）。

5x5实现需要两个临时变量、四个内存位置或寄存器（用于行机器的状态）、SR0到SR3以及四个列状态缓冲区。列状态缓冲区在整个操作开始时设置为零，行状态缓冲区在每行开始时设置为零。主循环代码如下所示。输出被写入地址[j-2][i-2]，因为这是当前5x5邻域的中心。见图3。

因此，5x5 SKIPSM的实现需要17个步骤。相比之下，这种情况下的暴力方法需要72个步骤（25个双索引像素提取、21个乘法、24个加法、1个缩放步骤和1个“写入”输出图像）。

现在将比较六个实现对于奇数N值所需的代码步数。“暴力”的方法被包括在比较中，尽管没有人会使用它。取而代之的是，他们要么使用分解，要么重复应用较小的模糊-通常是3x3。

下面是NxN高斯模糊的结果，对于N的各种奇数值:

可以看出，小SKIPSM算子的重复应用几乎等同于将所有步骤集成到一个SKIPSM算子中，并且任何一个都比暴力实现或分解要好得多。事实上，一步SKIPSM算法甚至比它看起来更好，因为它不仅消除了对中间图像的写入和读取（包括在这个计数中），但它消除了单独的双主回路所需的额外开销，这些回路用于每个单独的通道（不包括在此计数中）。

最后，使用组合SKIPSM方法的另一个真正优点是消除舍入误差。通过将任何舍入/缩放步骤推迟到操作结束，始终保持完全的精度，更接近高斯理想，并且完全避免小核中涉及的相当粗糙的近似。

## 4. 非方形高斯模糊

没有理由将自己局限于平方运算符或奇数运算符。任何尺寸的行机可与任何尺寸的列机配合使用(唯一的困难在于当N为偶数时决定将结果放在何处。）对于具有N列[（N-1）行状态]和M行[（M-1）列状态缓冲区]的SKIPSM模糊运算符，主循环代码步数变为1+2*（N-1）+2*（M-1）=（2*N+2*M-3）。

## 5. ROTATED ELLIPTICAL GAUSSIAN BLURS

甚至不需要将非圆形模糊的轴与图像的x和y轴对齐。也可以使用两个对角线有限状态机来产生相对于这些轴旋转45度的椭圆模糊。对角线机器用于灰度侵蚀，类似的方法很容易适应高斯模糊。这里省略了细节。

## 6. 三维和 N 维度高斯模糊
